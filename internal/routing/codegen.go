package routing

import (
	"fmt"
	"go/format"
	"os"
	"path/filepath"
	"sort"
	"strings"
)

// CodeGenerator generates the routes.gen.go file
type CodeGenerator struct {
	RouteTree   *RouteNode
	ModulePath  string
	ProjectRoot string // Absolute path to project root
	OutputFile  string
}

// Generate creates the routes.gen.go file
func (g *CodeGenerator) Generate() error {
	// Collect all routes and their metadata
	routes := g.collectRoutes(g.RouteTree)

	// Sort routes for consistent output
	sort.Slice(routes, func(i, j int) bool {
		return routes[i].GetFullPath() < routes[j].GetFullPath()
	})

	// Generate code
	code := g.generateCode(routes)

	// Format code
	formatted, err := format.Source([]byte(code))
	if err != nil {
		// If formatting fails, write unformatted code for debugging
		fmt.Printf("Warning: code formatting failed: %v\n", err)
		formatted = []byte(code)
	}

	// Write to file
	if err := os.WriteFile(g.OutputFile, formatted, 0644); err != nil {
		return fmt.Errorf("writing output file: %w", err)
	}

	return nil
}

func (g *CodeGenerator) collectRoutes(node *RouteNode) []*RouteNode {
	routes := make([]*RouteNode, 0)

	if node.HandlerFile != "" {
		routes = append(routes, node)
	}

	for _, child := range node.Children {
		routes = append(routes, g.collectRoutes(child)...)
	}

	return routes
}

func (g *CodeGenerator) generateCode(routes []*RouteNode) string {
	var sb strings.Builder

	// Header
	sb.WriteString("// Code generated by twine routes generate. DO NOT EDIT.\n\n")
	sb.WriteString("package app\n\n")

	// Imports
	sb.WriteString("import (\n")
	sb.WriteString("\t\"github.com/cstone-io/twine/kit\"\n")
	sb.WriteString("\t\"github.com/cstone-io/twine/router\"\n")
	sb.WriteString("\t\"github.com/cstone-io/twine/middleware\"\n")
	sb.WriteString("\n")

	// Collect unique package imports
	imports := g.collectImports(routes)
	for alias, path := range imports {
		sb.WriteString(fmt.Sprintf("\t%s \"%s\"\n", alias, path))
	}

	sb.WriteString(")\n\n")

	// Helper function for middleware
	sb.WriteString("// applyMiddleware wraps a handler with a middleware chain\n")
	sb.WriteString("func applyMiddleware(middlewares []middleware.Middleware, handler kit.HandlerFunc) kit.HandlerFunc {\n")
	sb.WriteString("\tif len(middlewares) == 0 {\n")
	sb.WriteString("\t\treturn handler\n")
	sb.WriteString("\t}\n")
	sb.WriteString("\treturn middleware.ApplyMiddlewares(handler, middlewares...)\n")
	sb.WriteString("}\n\n")

	// RegisterRoutes function
	sb.WriteString("// RegisterRoutes registers all file-based routes\n")
	sb.WriteString("func RegisterRoutes(r *router.Router) {\n")

	// Group routes by prefix (pages vs api)
	pageRoutes := make([]*RouteNode, 0)
	apiRoutes := make([]*RouteNode, 0)

	for _, route := range routes {
		if route.IsAPI || strings.HasPrefix(route.GetFullPath(), "/api") {
			apiRoutes = append(apiRoutes, route)
		} else {
			pageRoutes = append(pageRoutes, route)
		}
	}

	// Generate page routes
	if len(pageRoutes) > 0 {
		sb.WriteString("\t// Page routes\n")
		for _, route := range pageRoutes {
			g.generateRouteRegistration(&sb, route, "r")
		}
		sb.WriteString("\n")
	}

	// Generate API routes
	if len(apiRoutes) > 0 {
		sb.WriteString("\t// API routes\n")
		for _, route := range apiRoutes {
			g.generateRouteRegistration(&sb, route, "r")
		}
	}

	sb.WriteString("}\n")

	return sb.String()
}

func (g *CodeGenerator) collectImports(routes []*RouteNode) map[string]string {
	imports := make(map[string]string)
	seen := make(map[string]bool)

	for _, route := range routes {
		// Add handler package import
		packagePath := g.getPackagePath(route)
		alias := route.GetPackageAlias()

		// Ensure unique aliases
		if seen[alias] {
			// Add numeric suffix for duplicates
			counter := 2
			for {
				newAlias := fmt.Sprintf("%s%d", alias, counter)
				if !seen[newAlias] {
					alias = newAlias
					break
				}
				counter++
			}
		}

		imports[alias] = packagePath
		seen[alias] = true

		// Add layout package imports
		chain := g.buildLayoutChain(route)
		for _, layout := range chain.Layouts {
			layoutAlias := layout.PackageName
			if seen[layoutAlias] {
				// Already imported
				continue
			}
			imports[layoutAlias] = layout.PackagePath
			seen[layoutAlias] = true
		}
	}

	return imports
}

func (g *CodeGenerator) generateRouteRegistration(sb *strings.Builder, route *RouteNode, routerVar string) {
	urlPattern := route.ToURLPattern()
	alias := route.GetPackageAlias()

	// Build layout chain
	chain := g.buildLayoutChain(route)

	// Generate layout middleware setup if needed
	var middlewareVar string
	if chain.HasLayouts() {
		middlewareVar = fmt.Sprintf("%s_middleware", strings.ReplaceAll(alias, "/", "_"))
		sb.WriteString(fmt.Sprintf("\t// Layout chain for %s\n", urlPattern))

		// Build middleware chain from layouts
		sb.WriteString(fmt.Sprintf("\t%s := []middleware.Middleware{\n", middlewareVar))
		for _, layout := range chain.Layouts {
			sb.WriteString(fmt.Sprintf("\t\t%s.%s(),\n", layout.PackageName, layout.FuncName))
		}
		sb.WriteString("\t}\n")
	}

	// Register each HTTP method
	for _, method := range route.Methods {
		handler := fmt.Sprintf("%s.%s", alias, method)
		methodName := getRouterMethodName(method)

		if middlewareVar != "" {
			// Wrap handler with middleware
			wrappedHandler := fmt.Sprintf("applyMiddleware(%s, %s)", middlewareVar, handler)
			sb.WriteString(fmt.Sprintf("\t%s.%s(\"%s\", %s)\n",
				routerVar,
				methodName,
				urlPattern,
				wrappedHandler))
		} else {
			// Direct handler registration
			sb.WriteString(fmt.Sprintf("\t%s.%s(\"%s\", %s)\n",
				routerVar,
				methodName,
				urlPattern,
				handler))
		}
	}
}

// GetModulePath parses go.mod to extract module name
func GetModulePath(projectRoot string) (string, error) {
	goModPath := filepath.Join(projectRoot, "go.mod")
	data, err := os.ReadFile(goModPath)
	if err != nil {
		return "", fmt.Errorf("reading go.mod: %w", err)
	}

	lines := strings.Split(string(data), "\n")
	for _, line := range lines {
		line = strings.TrimSpace(line)
		if strings.HasPrefix(line, "module ") {
			return strings.TrimSpace(strings.TrimPrefix(line, "module")), nil
		}
	}

	return "", fmt.Errorf("module declaration not found in go.mod")
}

// getPackagePath returns Go import path for handler package relative to project root
func (g *CodeGenerator) getPackagePath(node *RouteNode) string {
	// Get relative path from project root
	relPath, err := filepath.Rel(g.ProjectRoot, node.Path)
	if err != nil {
		// Fallback to removing project root prefix
		relPath = strings.TrimPrefix(node.Path, g.ProjectRoot+"/")
	}

	// Don't sanitize - use actual directory path for imports
	// The package name inside the directory will be sanitized
	return g.ModulePath + "/" + relPath
}

// buildLayoutChain builds layout chain for a route
func (g *CodeGenerator) buildLayoutChain(node *RouteNode) *LayoutChain {
	chain := &LayoutChain{
		Layouts: make([]LayoutInfo, 0),
	}

	current := node
	for current != nil {
		if current.HasLayout {
			layout := LayoutInfo{
				FilePath:    current.LayoutFile,
				PackagePath: g.getPackagePath(current),
				PackageName: current.GetPackageAlias(),
				FuncName:    "Layout",
			}
			// Prepend to maintain order from root to leaf
			chain.Layouts = append([]LayoutInfo{layout}, chain.Layouts...)
		}
		current = current.Parent
	}

	return chain
}

// getRouterMethodName converts HTTP method to router method name
func getRouterMethodName(method string) string {
	switch method {
	case "GET":
		return "Get"
	case "POST":
		return "Post"
	case "PUT":
		return "Put"
	case "DELETE":
		return "Delete"
	case "PATCH":
		return "Patch"
	default:
		return method
	}
}
